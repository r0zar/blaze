This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-18T17:07:20.541Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
src/
  balance.ts
  client.ts
  constants.ts
  index.ts
  structured-data.ts
  subnet-transactions.ts
  subnet.ts
  transactions.ts
  types.ts
tests/
  balance.test.ts
  client.test.ts
  index.test.ts
  setup.ts
  signature.test.ts
  subnet-transactions.test.ts
  transactions.test.ts
.gitignore
.npmignore
package.json
README.md
tsconfig.json
tsup.config.ts
vitest.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/balance.ts">
import { kv } from '@vercel/kv';
import { fetchCallReadOnlyFunction, Cl, ClarityType } from '@stacks/transactions';
import { STACKS_MAINNET } from '@stacks/network';
/**
 * Get the storage key for a user's balance
 */
export function getBalanceKey(contract: string, user: string, type: 'confirmed' | 'unconfirmed'): string {
    return `${contract}:${user}:${type}`;
}
/**
 * Fetch a user's on-chain balance from the contract
 */
export async function fetchContractBalance(contract: string, user: string): Promise<number> {
    const [contractAddress, contractName] = contract.split('.');
    try {
        const result = await fetchCallReadOnlyFunction({
            contractAddress,
            contractName,
            functionName: 'get-balance',
            functionArgs: [Cl.principal(user)],
            network: STACKS_MAINNET,
            senderAddress: user
        });
        return result.type === ClarityType.UInt ? Number(result.value) : 0;
    } catch (error) {
        console.error('Failed to fetch contract balance:', error);
        return 0;
    }
}
/**
 * Get a user's confirmed balance from KV store, fetching from contract if not found
 */
export async function getConfirmedBalance(contract: string, user: string): Promise<number> {
    const key = getBalanceKey(contract, user, 'confirmed');
    const storedBalance = await kv.get<number>(key);
    if (storedBalance === null) {
        // First time: fetch from contract and store
        const contractBalance = await fetchContractBalance(contract, user);
        await kv.set(key, contractBalance);
        return contractBalance;
    }
    return storedBalance;
}
/**
 * Get a user's unconfirmed balance changes from KV store
 */
export async function getUnconfirmedBalance(contract: string, user: string): Promise<number> {
    const key = getBalanceKey(contract, user, 'unconfirmed');
    return await kv.get<number>(key) ?? 0;
}
/**
 * Update a user's confirmed balance in KV store
 */
export async function updateConfirmedBalance(contract: string, user: string, amount: number): Promise<void> {
    const key = getBalanceKey(contract, user, 'confirmed');
    await kv.set(key, amount);
}
/**
 * Update a user's unconfirmed balance in KV store
 */
export async function updateUnconfirmedBalance(contract: string, user: string, amount: number): Promise<void> {
    const key = getBalanceKey(contract, user, 'unconfirmed');
    await kv.set(key, amount);
}
/**
 * Get a user's complete balance information
 */
export async function getFullBalance(contract: string, user: string): Promise<{ confirmed: number; unconfirmed: number; total: number }> {
    const [confirmed, unconfirmed] = await Promise.all([
        getConfirmedBalance(contract, user),
        getUnconfirmedBalance(contract, user)
    ]);
    return {
        confirmed,
        unconfirmed,
        total: confirmed + unconfirmed
    };
}
/**
 * Process a deposit event from chainhook
 * The event represents the true state, so we update KV to match
 */
export async function processDepositEvent(contract: string, user: string, amount: number): Promise<void> {
    const key = getBalanceKey(contract, user, 'confirmed');
    const currentBalance = await kv.get<number>(key) ?? 0;
    await kv.set(key, currentBalance + amount);
    console.log(`Deposit event processed for ${user}, new balance: ${currentBalance + amount}`);
}
/**
 * Process a withdrawal event from chainhook
 * The event represents the true state, so we update KV to match
 */
export async function processWithdrawEvent(contract: string, user: string, amount: number): Promise<void> {
    const key = getBalanceKey(contract, user, 'confirmed');
    const currentBalance = await kv.get<number>(key) ?? 0;
    await kv.set(key, currentBalance - amount);
    console.log(`Withdrawal event processed for ${user}, new balance: ${currentBalance - amount}`);
}
/**
 * Process a transfer event from chainhook
 * The event represents the true state, so we update KV to match
 */
export async function processTransferEvent(contract: string, from: string, to: string, amount: number): Promise<void> {
    const fromKeyUnconfirmed = getBalanceKey(contract, from, 'unconfirmed');
    const fromKeyConfirmed = getBalanceKey(contract, from, 'confirmed');
    const toKeyUnconfirmed = getBalanceKey(contract, to, 'unconfirmed');
    const toKeyConfirmed = getBalanceKey(contract, to, 'confirmed');
    const [fromBalanceConfirmedOrNull, toBalanceConfirmedOrNull] = await Promise.all([
        kv.get<number>(fromKeyConfirmed),
        kv.get<number>(toKeyConfirmed)
    ]);
    const [fromBalanceUnconfirmedOrNull, toBalanceUnconfirmedOrNull] = await Promise.all([
        kv.get<number>(fromKeyUnconfirmed),
        kv.get<number>(toKeyUnconfirmed)
    ]);
    const fromBalanceUnconfirmed = fromBalanceUnconfirmedOrNull ?? 0;
    const toBalanceUnconfirmed = toBalanceUnconfirmedOrNull ?? 0;
    const fromBalanceConfirmed = fromBalanceConfirmedOrNull ?? 0;
    const toBalanceConfirmed = toBalanceConfirmedOrNull ?? 0;
    // Update both balances to match chain state
    await Promise.all([
        kv.set(fromKeyConfirmed, fromBalanceConfirmed - amount),
        kv.set(toKeyConfirmed, toBalanceConfirmed + amount),
        kv.set(fromKeyUnconfirmed, fromBalanceUnconfirmed - amount),
        kv.set(toKeyUnconfirmed, toBalanceUnconfirmed + amount)
    ]);
    console.log(`Transfer event processed for ${from} -> ${to}, new balances: ${fromBalanceConfirmed - amount} and ${toBalanceConfirmed + amount}`);
}
</file>

<file path="src/client.ts">
import { makeContractCall, broadcastTransaction, TxBroadcastResult, signStructuredData } from '@stacks/transactions';
import { STACKS_MAINNET } from '@stacks/network';
import { Balance } from '.';
import { createBlazeDomain, createBlazeMessage } from './structured-data';
import { NODE_URL, SUBNETS } from './constants';
import { buildDepositTxOptions, buildWithdrawTxOptions } from './transactions';
import type { FinishedTxData } from './types';
import axios from 'axios';
export interface TransferOptions {
    to: string;
    amount: number;
}
export interface TransactionResult {
    txid: string;
}
export class Blaze {
    private subnet: string;
    private tokenIdentifier: string;
    private signer: string;
    private isServer: boolean;
    constructor(subnet: string, signer: string) {
        this.signer = signer;
        this.isServer = typeof window === 'undefined';
        if (!subnet) {
            throw new Error('Subnet contract address is required');
        }
        this.subnet = subnet;
        this.tokenIdentifier = SUBNETS[subnet as keyof typeof SUBNETS];
        if (!this.tokenIdentifier) {
            throw new Error(`No token identifier found for subnet: ${subnet}`);
        }
    }
    private async executeServerTransaction(txOptions: any): Promise<TransactionResult> {
        if (!process.env.PRIVATE_KEY) {
            throw new Error('PRIVATE_KEY environment variable not set');
        }
        const transaction = await makeContractCall({
            ...txOptions,
            senderKey: process.env.PRIVATE_KEY,
            network: STACKS_MAINNET,
        });
        const response: TxBroadcastResult = await broadcastTransaction({
            transaction,
            network: STACKS_MAINNET,
        });
        if ('error' in response) throw new Error(response.error);
        return { txid: response.txid };
    }
    async getBalance() {
        const response = await axios.get(`${NODE_URL}/subnets/${this.subnet}/balances/${this.signer}`);
        return response.data as Balance;
    }
    private async signServerTransfer(message: any, domain: any): Promise<string> {
        if (!process.env.PRIVATE_KEY) {
            throw new Error('PRIVATE_KEY environment variable not set');
        }
        return signStructuredData({ message, domain, privateKey: process.env.PRIVATE_KEY });
    }
    async transfer(options: TransferOptions) {
        const nextNonce = Date.now();
        const tokens = options.amount;
        const domain = createBlazeDomain();
        const message = createBlazeMessage({
            to: options.to,
            amount: tokens,
            nonce: nextNonce
        });
        let signature: string;
        if (this.isServer) {
            signature = await this.signServerTransfer(message, domain);
        } else {
            const { openStructuredDataSignatureRequestPopup } = await import("@stacks/connect");
            const result: any = await new Promise((resolve) => {
                openStructuredDataSignatureRequestPopup({
                    domain,
                    message,
                    network: STACKS_MAINNET,
                    onFinish: (data) => resolve(data),
                    onCancel: () => resolve(null)
                });
            });
            if (!result?.signature) throw new Error('User cancelled or signing failed');
            signature = result.signature;
        }
        // send signature to the node for processing
        const response = await axios.post(`${NODE_URL}/subnets/${this.subnet}/xfer`, {
            signature,
            signer: this.signer,
            to: options.to,
            amount: tokens,
            nonce: nextNonce,
        });
        if (response.status !== 200) {
            console.error(`Transfer failed: ${response.statusText}`);
        }
        return response.data;
    }
    async deposit(amount: number) {
        const txOptions = buildDepositTxOptions({
            subnet: this.subnet,
            tokenIdentifier: this.tokenIdentifier,
            signer: this.signer,
            amount
        });
        if (this.isServer) {
            return this.executeServerTransaction(txOptions);
        }
        const { showContractCall } = await import("@stacks/connect");
        const result = await new Promise<FinishedTxData | null>((resolve) => {
            showContractCall({
                ...txOptions,
                network: STACKS_MAINNET,
                onFinish: (data) => resolve(data),
                onCancel: () => resolve(null)
            });
        });
        if (!result?.txId) {
            console.error('Transaction cancelled or failed');
        }
        return result;
    }
    async withdraw(amount: number) {
        const txOptions = buildWithdrawTxOptions({
            subnet: this.subnet,
            tokenIdentifier: this.tokenIdentifier,
            amount
        });
        if (this.isServer) {
            return this.executeServerTransaction(txOptions);
        }
        const { showContractCall } = await import("@stacks/connect");
        const result = await new Promise<FinishedTxData | null>((resolve) => {
            showContractCall({
                ...txOptions,
                network: STACKS_MAINNET,
                onFinish: (data) => resolve(data),
                onCancel: () => resolve(null)
            });
        });
        if (!result?.txId) {
            console.error('Transaction cancelled or failed');
        }
        return result;
    }
}
</file>

<file path="src/constants.ts">
export const SUBNETS = {
    'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.blaze-welsh-v0':
        'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token::welshcorgicoin'
} as const;
export const NODE_URL = '/api/v0/blaze';
</file>

<file path="src/index.ts">
import 'dotenv/config';
export * from './balance';
export * from './subnet';
export * from './client';
export * from './constants';
export * from './structured-data';
</file>

<file path="src/structured-data.ts">
import { Cl } from '@stacks/transactions';
import { STACKS_MAINNET } from '@stacks/network';
export interface BlazeMessage {
    to: string;
    amount: number;
    nonce: number;
}
/**
 * Creates a consistent domain tuple for Blaze signatures
 */
export function createBlazeDomain() {
    return Cl.tuple({
        name: Cl.stringAscii("blaze"),
        version: Cl.stringAscii("0.1.1"),
        "chain-id": Cl.uint(STACKS_MAINNET.chainId),
    });
}
/**
 * Creates a consistent message tuple for Blaze signatures
 */
export function createBlazeMessage(message: BlazeMessage) {
    return Cl.tuple({
        to: Cl.principal(message.to),
        amount: Cl.uint(message.amount),
        nonce: Cl.uint(message.nonce)
    });
}
</file>

<file path="src/subnet-transactions.ts">
import { Cl, makeContractCall, broadcastTransaction, TxBroadcastResult } from '@stacks/transactions';
import { STACKS_MAINNET } from '@stacks/network';
import { Transfer } from './subnet';
export interface BatchTransferOptions {
    contract: string;
    operations: Transfer[];
    privateKey: string;
}
export interface SingleTransferOptions {
    contract: string;
    operation: Transfer;
    privateKey: string;
}
export interface TransferResult {
    txid: string;
    status: 'success' | 'failed';
}
export function validateTransferOperation(operation: Transfer): void {
    if (!operation.to || !operation.signer || !operation.signature) {
        throw new Error('Invalid transfer operation: missing required fields');
    }
    if (operation.amount <= 0) {
        throw new Error('Invalid transfer operation: amount must be positive');
    }
    if (operation.nonce <= 0) {
        throw new Error('Invalid transfer operation: nonce must be positive');
    }
}
export function buildSingleTransferTxOptions(params: SingleTransferOptions) {
    const { contract, operation, privateKey } = params;
    if (!contract || !privateKey) {
        throw new Error('Invalid parameters for building transfer transaction');
    }
    // Validate operation
    validateTransferOperation(operation);
    const [contractAddress, contractName] = contract.split('.');
    if (!contractAddress || !contractName) {
        throw new Error('Invalid contract format');
    }
    return {
        contractAddress,
        contractName,
        functionName: 'transfer',
        functionArgs: [
            Cl.bufferFromHex(operation.signature),
            Cl.principal(operation.signer),
            Cl.principal(operation.to),
            Cl.uint(operation.amount),
            Cl.uint(operation.nonce)
        ],
        senderKey: privateKey,
        network: STACKS_MAINNET,
        fee: 1800
    };
}
export function buildBatchTransferTxOptions(params: BatchTransferOptions) {
    const { contract, operations, privateKey } = params;
    if (!contract || !operations.length || !privateKey) {
        throw new Error('Invalid parameters for building batch transfer transaction');
    }
    // Validate each operation
    operations.forEach(validateTransferOperation);
    const [contractAddress, contractName] = contract.split('.');
    if (!contractAddress || !contractName) {
        throw new Error('Invalid contract format');
    }
    const clarityOperations = operations.map(op => {
        return Cl.tuple({
            signature: Cl.bufferFromHex(op.signature),
            signer: Cl.principal(op.signer),
            to: Cl.principal(op.to),
            amount: Cl.uint(op.amount),
            nonce: Cl.uint(op.nonce),
        });
    });
    return {
        contractAddress,
        contractName,
        functionName: 'batch-transfer',
        functionArgs: [Cl.list(clarityOperations)],
        senderKey: privateKey,
        network: STACKS_MAINNET,
        fee: 1800
    };
}
export async function executeTransfer(params: SingleTransferOptions): Promise<TransferResult> {
    const txOptions = buildSingleTransferTxOptions(params);
    const transaction = await makeContractCall(txOptions as any);
    console.log('Transaction:', transaction);
    const response: TxBroadcastResult = await broadcastTransaction({
        transaction,
        network: STACKS_MAINNET,
    });
    if ('error' in response) throw new Error(response.error);
    console.log('Transfer broadcasted:', response);
    return {
        txid: response.txid,
        status: response.txid ? 'success' : 'failed'
    };
}
export async function executeBatchTransfer(params: BatchTransferOptions): Promise<TransferResult> {
    const txOptions = buildBatchTransferTxOptions(params);
    const transaction = await makeContractCall(txOptions as any);
    console.log('Transaction:', transaction);
    const response: TxBroadcastResult = await broadcastTransaction({
        transaction,
        network: STACKS_MAINNET,
    });
    if ('error' in response) throw new Error(response.error);
    console.log('Batch transfer broadcasted:', response);
    return {
        txid: response.txid,
        status: response.txid ? 'success' : 'failed'
    };
}
</file>

<file path="src/subnet.ts">
import { fetchCallReadOnlyFunction, Cl, ClarityType, signStructuredData } from '@stacks/transactions';
import { STACKS_MAINNET } from '@stacks/network';
import { getFullBalance, updateUnconfirmedBalance } from './balance';
import { createBlazeDomain, createBlazeMessage } from './structured-data';
import { executeBatchTransfer, executeTransfer, TransferResult } from './subnet-transactions';
import 'dotenv/config';
/**
 * Core types
 */
export interface Transfer {
    signature: string;
    signer: string;
    to: string;
    amount: number;
    nonce: number;
}
export interface Balance {
    confirmed: number;
    unconfirmed: number;
    total: number;
}
export interface Status {
    contracts: string[];
    queueSizes: { [contract: string]: number };
    lastProcessedBlock?: number;
}
export class Subnet {
    contract: string;
    queue: Transfer[];
    lastProcessedBlock: number;
    constructor(contract: string) {
        if (!contract) {
            throw new Error('Contract address is required');
        }
        this.contract = contract;
        this.queue = [];
        this.lastProcessedBlock = 0;
    }
    public getStatus(): Status {
        return {
            contracts: [this.contract],
            queueSizes: { [this.contract]: this.queue.length },
            lastProcessedBlock: this.lastProcessedBlock
        };
    }
    public async getBalance(user: string): Promise<Balance> {
        return await getFullBalance(this.contract, user);
    }
    public async addTransferToQueue(transfer: Transfer): Promise<void> {
        // verify the balances
        const balances = await this.getBalance(transfer.signer);
        if (balances.confirmed < transfer.amount) {
            throw new Error('Insufficient balance');
        }
        // Update unconfirmed balances
        await Promise.all([
            updateUnconfirmedBalance(
                this.contract,
                transfer.signer,
                -transfer.amount
            ),
            updateUnconfirmedBalance(
                this.contract,
                transfer.to,
                transfer.amount
            )
        ]);
        // Add to queue
        this.queue.push(transfer);
        console.log('Added transfer to queue:', transfer);
    }
    async verifySignature(transfer: Transfer): Promise<boolean> {
        const [contractAddress, contractName] = this.contract.split('.');
        try {
            const result = await fetchCallReadOnlyFunction({
                contractAddress,
                contractName,
                functionName: 'verify-signature',
                functionArgs: [
                    Cl.bufferFromHex(transfer.signature),
                    Cl.principal(transfer.signer),
                    Cl.principal(transfer.to),
                    Cl.uint(transfer.amount),
                    Cl.uint(transfer.nonce)
                ],
                network: STACKS_MAINNET,
                senderAddress: transfer.signer
            });
            return result.type === ClarityType.BoolTrue;
        } catch (error) {
            console.error('Signature verification failed:', error);
            return false;
        }
    }
    async executeTransfer(transfer: Transfer): Promise<TransferResult> {
        if (!process.env.PRIVATE_KEY) {
            throw new Error('PRIVATE_KEY environment variable not set');
        }
        // Verify signature before executing
        const isValid = await this.verifySignature(transfer);
        if (!isValid) {
            throw new Error('Invalid signature');
        }
        // Update unconfirmed balances
        await Promise.all([
            updateUnconfirmedBalance(
                this.contract,
                transfer.signer,
                -transfer.amount
            ),
            updateUnconfirmedBalance(
                this.contract,
                transfer.to,
                transfer.amount
            )
        ]);
        return executeTransfer({
            contract: this.contract,
            operation: transfer,
            privateKey: process.env.PRIVATE_KEY
        });
    }
    async processTransfers(): Promise<TransferResult | void> {
        if (!process.env.PRIVATE_KEY) {
            throw new Error('PRIVATE_KEY environment variable not set');
        }
        const queueLength = this.queue.length;
        if (queueLength === 0) return;
        console.log('Processing transfers:', queueLength);
        const result = await executeBatchTransfer({
            contract: this.contract,
            operations: this.queue,
            privateKey: process.env.PRIVATE_KEY
        });
        if (result.status === 'success') {
            this.queue.splice(0, queueLength);
        }
        return result;
    }
    signTransfer(to: string, amount: number, nonce: number) {
        const domain = createBlazeDomain();
        const message = createBlazeMessage({ to, amount, nonce });
        return signStructuredData({ message, domain, privateKey: process.env.PRIVATE_KEY! });
    }
}
</file>

<file path="src/transactions.ts">
import { Cl, Pc, PostConditionMode } from '@stacks/transactions';
export interface TransactionOptions {
    contractAddress: string;
    contractName: string;
    functionName: string;
    functionArgs: any[];
    postConditions: any[];
    postConditionMode: PostConditionMode;
}
export interface BuildDepositTxOptionsParams {
    subnet: string;
    tokenIdentifier: string;
    signer: string;
    amount: number;
}
export interface BuildWithdrawTxOptionsParams {
    subnet: string;
    tokenIdentifier: string;
    amount: number;
}
export function buildDepositTxOptions(params: BuildDepositTxOptionsParams): TransactionOptions {
    const { subnet, tokenIdentifier, signer, amount } = params;
    if (!subnet || !tokenIdentifier || !signer || amount <= 0) {
        throw new Error('Invalid parameters for building deposit transaction options');
    }
    const [contractAddress, contractName] = subnet.split('.');
    const [tokenContract, tokenName] = tokenIdentifier.split('::');
    if (!contractAddress || !contractName || !tokenContract || !tokenName) {
        throw new Error('Invalid subnet or token identifier format');
    }
    return {
        contractAddress,
        contractName,
        functionName: "deposit",
        functionArgs: [Cl.uint(amount)],
        postConditions: [Pc.principal(signer).willSendEq(amount).ft(tokenContract as any, tokenName)],
        postConditionMode: PostConditionMode.Deny,
    };
}
export function buildWithdrawTxOptions(params: BuildWithdrawTxOptionsParams): TransactionOptions {
    const { subnet, tokenIdentifier, amount } = params;
    if (!subnet || !tokenIdentifier || amount <= 0) {
        throw new Error('Invalid parameters for building withdraw transaction options');
    }
    const [contractAddress, contractName] = subnet.split('.');
    const [tokenContract, tokenName] = tokenIdentifier.split('::');
    if (!contractAddress || !contractName || !tokenContract || !tokenName) {
        throw new Error('Invalid subnet or token identifier format');
    }
    return {
        contractAddress,
        contractName,
        functionName: "withdraw",
        functionArgs: [Cl.uint(amount)],
        postConditions: [Pc.principal(tokenContract).willSendEq(amount).ft(tokenContract as any, tokenName)],
        postConditionMode: PostConditionMode.Deny,
    };
}
</file>

<file path="src/types.ts">
import type { ContractCallOptions as StacksContractCallOptions } from '@stacks/connect';
export interface FinishedTxData {
    txId: string;
    txRaw: string;
    stacksTransaction: any;
}
export type ContractCallOptions = StacksContractCallOptions;
</file>

<file path="tests/balance.test.ts">
import { describe, it, expect } from 'vitest';
import { getFullBalance, processDepositEvent, processWithdrawEvent, Subnet, updateConfirmedBalance, updateUnconfirmedBalance } from '../src';
describe('Balance', () => {
    const contract = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.blaze-welsh-v0';
    const signer = 'SP2MR4YP9C7P93EJZC4W1JT8HKAX8Q4HR9Q6X3S88';
    it('should get the balance of a user', async () => {
        const balance = await getFullBalance(contract, signer);
        console.log('Balance:', balance);
    });
    it('should reset a unconfirmed balance', async () => {
        await updateUnconfirmedBalance(contract, signer, 0);
        const balance = await getFullBalance(contract, signer);
        console.log('Balance:', balance);
    });
    it('should reset a confirmed balance', async () => {
        await updateConfirmedBalance(contract, signer, 0);
        const balance = await getFullBalance(contract, signer);
        console.log('Balance:', balance);
    });
    it('should process a deposit event', async () => {
        await processDepositEvent(contract, signer, 100);
        const balance = await getFullBalance(contract, signer);
        console.log('Balance:', balance);
    });
    it('should process a withdrawal event', async () => {
        await processWithdrawEvent(contract, signer, 100);
        const balance = await getFullBalance(contract, signer);
        console.log('Balance:', balance);
    });
});
</file>

<file path="tests/client.test.ts">
// should create a real deposit and withdraw
import { describe, it } from 'vitest';
import { Blaze } from '../src';
const contract = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.blaze-welsh-v0';
const signer = 'SP2MR4YP9C7P93EJZC4W1JT8HKAX8Q4HR9Q6X3S88';
describe('Blaze Client', () => {
    it('should create a real deposit', async () => {
        const client = new Blaze(contract, signer);
        // const result = await client.deposit(100);
        // console.log('Deposit result:', result);
    });
    it('should create a real withdraw', async () => {
        const client = new Blaze(contract, signer);
        // const result = await client.withdraw(100);
        // console.log('Withdraw result:', result);
    });
});
</file>

<file path="tests/index.test.ts">
import { describe, it } from 'vitest';
import { Subnet } from '../src/index';
describe('Subnet Read Functions', () => {
    const contract = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.blaze-welsh-v0';
    const userAddress = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS';
    const subnet = new Subnet(contract);
    it('should get contract balance', async () => {
        const balance = await subnet.getBalance(userAddress);
        console.log('Contract Balance:', balance);
    });
    it('should get node status', () => {
        const status = subnet.getStatus();
        console.log('Node Status:', status);
    });
});
</file>

<file path="tests/setup.ts">
import { vi } from 'vitest'
import { config } from 'dotenv';
import { resolve } from 'path';
// Load environment variables from .env file
config({ path: resolve(__dirname, '../.env') });
// Ensure required environment variables are set
if (!process.env.PRIVATE_KEY) {
  throw new Error('PRIVATE_KEY environment variable must be set for tests');
}
// Mock @stacks/connect
vi.mock('@stacks/connect', () => ({
  openContractCall: vi.fn(),
  openContractDeploy: vi.fn(),
  signMessage: vi.fn(),
  showSignMessage: vi.fn(),
}));
</file>

<file path="tests/signature.test.ts">
import { describe, test, expect } from 'vitest';
import { Subnet } from '../src';
describe('Signature Generation and Verification', () => {
    const contract = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.blaze-welsh-v0';
    const signer = 'SP2MR4YP9C7P93EJZC4W1JT8HKAX8Q4HR9Q6X3S88';
    const to = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS';
    const amount = 10;
    const nonce = Date.now();
    test('should generate and verify a valid signature', async () => {
        const subnet = new Subnet(contract);
        // Generate signature using structured data utilities
        const signature = subnet.signTransfer(to, amount, nonce);
        // Verify the signature directly using contract
        const result = await subnet.verifySignature({ signature, signer, to, amount, nonce });
        expect(result).toBe(true);
    });
    // should issue a single transfer
    test('should issue a single transfer', async () => {
        const subnet = new Subnet(contract);
        const signature = subnet.signTransfer(to, amount, nonce);
        const result = await subnet.verifySignature({ signature, signer, to, amount, nonce });
        expect(result).toBe(true);
        const transfer = await subnet.executeTransfer({ signature, signer, to, amount, nonce });
        console.log('Transfer result:', transfer);
    });
    // should process a batch of transfers
    test('should process a batch of transfers', async () => {
        const subnet = new Subnet(contract);
        const signature1 = subnet.signTransfer(to, amount, nonce);
        const signature2 = subnet.signTransfer(to, amount, nonce + 1);
        const transfers = [
            {
                signature: signature1,
                signer,
                to,
                amount,
                nonce,
            },
            {
                signature: signature2,
                signer,
                to,
                amount,
                nonce: nonce + 1,
            }
        ];
        // get subnet status
        const status = subnet.getStatus();
        console.log('Subnet status:', status);
        await subnet.addTransferToQueue(transfers[0]);
        await subnet.addTransferToQueue(transfers[1]);
        const result = await subnet.processTransfers();
        console.log('Result:', result);
        const balance = await subnet.getBalance(signer);
        console.log('Balance:', balance);
    });
});
</file>

<file path="tests/subnet-transactions.test.ts">
import { describe, it, expect } from 'vitest';
import { validateTransferOperation, buildBatchTransferTxOptions } from '../src/subnet-transactions';
import { buildSingleTransferTxOptions } from '../src/subnet-transactions';
import { PostConditionMode } from '@stacks/transactions';
import type { Transfer } from '../src/subnet';
describe('Subnet Transaction Utilities', () => {
    const validTransfer: Transfer = {
        signer: 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS',
        to: 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G',
        amount: 100,
        nonce: 1234567890,
        signature: '0x1234567890abcdef'
    };
    describe('validateTransferOperation', () => {
        it('should validate a correct transfer operation', () => {
            expect(() => validateTransferOperation(validTransfer)).not.toThrow();
        });
        it('should throw error for missing to address', () => {
            const transfer = { ...validTransfer, to: '' };
            expect(() => validateTransferOperation(transfer)).toThrow('Invalid transfer operation: missing required fields');
        });
        it('should throw error for missing signer', () => {
            const transfer = { ...validTransfer, signer: '' };
            expect(() => validateTransferOperation(transfer)).toThrow('Invalid transfer operation: missing required fields');
        });
        it('should throw error for missing signature', () => {
            const transfer = { ...validTransfer, signature: '' };
            expect(() => validateTransferOperation(transfer)).toThrow('Invalid transfer operation: missing required fields');
        });
        it('should throw error for zero amount', () => {
            const transfer = { ...validTransfer, amount: 0 };
            expect(() => validateTransferOperation(transfer)).toThrow('Invalid transfer operation: amount must be positive');
        });
        it('should throw error for negative amount', () => {
            const transfer = { ...validTransfer, amount: -1 };
            expect(() => validateTransferOperation(transfer)).toThrow('Invalid transfer operation: amount must be positive');
        });
        it('should throw error for zero nonce', () => {
            const transfer = { ...validTransfer, nonce: 0 };
            expect(() => validateTransferOperation(transfer)).toThrow('Invalid transfer operation: nonce must be positive');
        });
        it('should throw error for negative nonce', () => {
            const transfer = { ...validTransfer, nonce: -1 };
            expect(() => validateTransferOperation(transfer)).toThrow('Invalid transfer operation: nonce must be positive');
        });
    });
    describe('buildBatchTransferTxOptions', () => {
        const validContract = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.blaze-welsh-v0';
        const validPrivateKey = process.env.PRIVATE_KEY!;
        it('should build valid transaction options', () => {
            const result = buildBatchTransferTxOptions({
                contract: validContract,
                operations: [validTransfer],
                privateKey: validPrivateKey
            });
            expect(result).toEqual({
                contractAddress: 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS',
                contractName: 'blaze-welsh-v0',
                functionName: 'batch-transfer',
                functionArgs: expect.any(Array),
                senderKey: validPrivateKey,
                network: expect.any(Object),
                fee: 1800
            });
        });
        it('should throw error for empty operations array', () => {
            expect(() => buildBatchTransferTxOptions({
                contract: validContract,
                operations: [],
                privateKey: validPrivateKey
            })).toThrow('Invalid parameters for building batch transfer transaction');
        });
        it('should throw error for invalid contract format', () => {
            expect(() => buildBatchTransferTxOptions({
                contract: 'invalid-contract',
                operations: [validTransfer],
                privateKey: validPrivateKey
            })).toThrow('Invalid contract format');
        });
        it('should throw error for missing private key', () => {
            expect(() => buildBatchTransferTxOptions({
                contract: validContract,
                operations: [validTransfer],
                privateKey: ''
            })).toThrow('Invalid parameters for building batch transfer transaction');
        });
        it('should validate all operations in the batch', () => {
            const invalidTransfer = { ...validTransfer, amount: 0 };
            expect(() => buildBatchTransferTxOptions({
                contract: validContract,
                operations: [validTransfer, invalidTransfer],
                privateKey: validPrivateKey
            })).toThrow('Invalid transfer operation: amount must be positive');
        });
    });
    describe('buildSingleTransferTxOptions', () => {
        const validContract = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.blaze-welsh-v0';
        const validPrivateKey = process.env.PRIVATE_KEY!;
        it('should build valid single transfer transaction options', () => {
            const result = buildSingleTransferTxOptions({
                contract: validContract,
                operation: validTransfer,
                privateKey: validPrivateKey
            });
            expect(result).toEqual({
                contractAddress: 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS',
                contractName: 'blaze-welsh-v0',
                functionName: 'transfer',
                functionArgs: expect.any(Array),
                senderKey: validPrivateKey,
                network: expect.any(Object),
                fee: 1800
            });
            // Verify function arguments are in the correct order as per the contract
            const functionArgs = result.functionArgs;
            expect(functionArgs).toHaveLength(5);
            expect(functionArgs[0]).toBeDefined(); // signature buffer
            expect(functionArgs[1]).toBeDefined(); // signer principal
            expect(functionArgs[2]).toBeDefined(); // to principal
            expect(functionArgs[3]).toBeDefined(); // amount uint
            expect(functionArgs[4]).toBeDefined(); // nonce uint
        });
        it('should throw error for invalid contract format', () => {
            expect(() => buildSingleTransferTxOptions({
                contract: 'invalid-contract',
                operation: validTransfer,
                privateKey: validPrivateKey
            })).toThrow('Invalid contract format');
        });
        it('should throw error for missing private key', () => {
            expect(() => buildSingleTransferTxOptions({
                contract: validContract,
                operation: validTransfer,
                privateKey: ''
            })).toThrow('Invalid parameters for building transfer transaction');
        });
        it('should validate the transfer operation', () => {
            const invalidTransfer = { ...validTransfer, amount: 0 };
            expect(() => buildSingleTransferTxOptions({
                contract: validContract,
                operation: invalidTransfer,
                privateKey: validPrivateKey
            })).toThrow('Invalid transfer operation: amount must be positive');
        });
    });
});
</file>

<file path="tests/transactions.test.ts">
import { describe, it, expect } from 'vitest';
import { buildDepositTxOptions, buildWithdrawTxOptions } from '../src/transactions';
import { PostConditionMode } from '@stacks/transactions';
describe('Transaction Utilities', () => {
    const validSubnet = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS.blaze-welsh-v0';
    const validToken = 'SP3NE50GEXFG9SZGTT51P40X2CKYSZ5CC4ZTZ7A2G.welshcorgicoin-token::welshcorgicoin';
    const validSigner = 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS';
    const validAmount = 100;
    describe('buildDepositTxOptions', () => {
        it('should build valid deposit transaction options', () => {
            const result = buildDepositTxOptions({
                subnet: validSubnet,
                tokenIdentifier: validToken,
                signer: validSigner,
                amount: validAmount
            });
            expect(result).toEqual({
                contractAddress: 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS',
                contractName: 'blaze-welsh-v0',
                functionName: 'deposit',
                functionArgs: expect.any(Array),
                postConditions: expect.any(Array),
                postConditionMode: PostConditionMode.Deny
            });
        });
        it('should throw error for invalid subnet format', () => {
            expect(() => buildDepositTxOptions({
                subnet: 'invalid-subnet',
                tokenIdentifier: validToken,
                signer: validSigner,
                amount: validAmount
            })).toThrow('Invalid subnet or token identifier format');
        });
        it('should throw error for invalid token format', () => {
            expect(() => buildDepositTxOptions({
                subnet: validSubnet,
                tokenIdentifier: 'invalid-token',
                signer: validSigner,
                amount: validAmount
            })).toThrow('Invalid subnet or token identifier format');
        });
        it('should throw error for zero amount', () => {
            expect(() => buildDepositTxOptions({
                subnet: validSubnet,
                tokenIdentifier: validToken,
                signer: validSigner,
                amount: 0
            })).toThrow('Invalid parameters for building deposit transaction options');
        });
        it('should throw error for negative amount', () => {
            expect(() => buildDepositTxOptions({
                subnet: validSubnet,
                tokenIdentifier: validToken,
                signer: validSigner,
                amount: -1
            })).toThrow('Invalid parameters for building deposit transaction options');
        });
    });
    describe('buildWithdrawTxOptions', () => {
        it('should build valid withdraw transaction options', () => {
            const result = buildWithdrawTxOptions({
                subnet: validSubnet,
                tokenIdentifier: validToken,
                amount: validAmount
            });
            expect(result).toEqual({
                contractAddress: 'SP2ZNGJ85ENDY6QRHQ5P2D4FXKGZWCKTB2T0Z55KS',
                contractName: 'blaze-welsh-v0',
                functionName: 'withdraw',
                functionArgs: expect.any(Array),
                postConditions: expect.any(Array),
                postConditionMode: PostConditionMode.Deny
            });
        });
        it('should throw error for invalid subnet format', () => {
            expect(() => buildWithdrawTxOptions({
                subnet: 'invalid-subnet',
                tokenIdentifier: validToken,
                amount: validAmount
            })).toThrow('Invalid subnet or token identifier format');
        });
        it('should throw error for invalid token format', () => {
            expect(() => buildWithdrawTxOptions({
                subnet: validSubnet,
                tokenIdentifier: 'invalid-token',
                amount: validAmount
            })).toThrow('Invalid subnet or token identifier format');
        });
        it('should throw error for zero amount', () => {
            expect(() => buildWithdrawTxOptions({
                subnet: validSubnet,
                tokenIdentifier: validToken,
                amount: 0
            })).toThrow('Invalid parameters for building withdraw transaction options');
        });
        it('should throw error for negative amount', () => {
            expect(() => buildWithdrawTxOptions({
                subnet: validSubnet,
                tokenIdentifier: validToken,
                amount: -1
            })).toThrow('Invalid parameters for building withdraw transaction options');
        });
    });
});
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/

# IDE files
.idea/
.vscode/
*.swp
*.swo

# Logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env
.env.*
!.env.example

# Testing
coverage/

# OS files
.DS_Store
Thumbs.db

# Clarinet
**/settings/Mainnet.toml
**/settings/Testnet.toml
.cache/**
history.txt
</file>

<file path=".npmignore">
# Source
src/
tests/

# Config files
tsconfig.json
tsup.config.ts
vitest.config.ts
.prettierrc
.eslintrc
.env*

# Development
node_modules/
coverage/
.vscode/
.idea/

# Git
.git/
.gitignore

# Logs
*.log
npm-debug.log*

# Misc
.DS_Store
</file>

<file path="package.json">
{
  "name": "blaze-sdk",
  "version": "0.1.36",
  "description": "SDK for managing off-chain transfers with on-chain settlement for Stacks dapps",
  "main": "dist/index.js",
  "module": "dist/index.mjs",
  "types": "dist/index.d.ts",
  "exports": {
    ".": {
      "require": "./dist/index.js",
      "import": "./dist/index.mjs"
    }
  },
  "files": [
    "dist",
    "README.md"
  ],
  "scripts": {
    "dev": "tsx --no-deprecation src/cli.ts",
    "dev:watch": "tsx watch src/cli.ts",
    "dev:debug": "node --inspect-brk -r tsx/cjs src/cli.ts",
    "build": "tsup",
    "clean": "rimraf dist",
    "prepare": "npm run clean && npm run build",
    "test": "vitest",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage",
    "lint": "eslint src --ext .ts",
    "format": "prettier --write \"src/**/*.ts\"",
    "prepublishOnly": "npm run build",
    "publish:check": "git diff-index --quiet HEAD || (echo 'Working directory not clean. Please commit or stash changes first.' && exit 1)",
    "publish:next": "npm run publish:check && npm publish --tag next && git push && git push --tags",
    "publish:latest": "npm run publish:check && npm publish --tag next && npm dist-tag add dexterity-sdk@$(npm pkg get version | sed 's/\"//g') latest && git push && git push --tags",
    "cli": "node --no-deprecation ./dist/cli.js",
    "typecheck": "tsc --noEmit"
  },
  "keywords": [
    "stacks",
    "blockchain",
    "scaling",
    "batching",
    "transfers"
  ],
  "author": "",
  "license": "MIT",
  "dependencies": {
    "@stacks/connect": "^7.0.2",
    "@stacks/network": "^7.0.2",
    "@stacks/transactions": "^7.0.2",
    "@vercel/kv": "^3.0.0",
    "axios": "^1.7.9",
    "dotenv": "^16.4.7"
  },
  "devDependencies": {
    "@types/node": "^20.0.0",
    "@typescript-eslint/eslint-plugin": "^6.0.0",
    "@typescript-eslint/parser": "^6.0.0",
    "@vitest/coverage-v8": "^1.0.0",
    "cross-fetch": "^4.0.0",
    "eslint": "^8.0.0",
    "prettier": "^3.0.0",
    "rimraf": "^6.0.1",
    "tsup": "^8.0.2",
    "tsx": "^4.7.0",
    "typescript": "^5.3.3",
    "vitest": "^1.2.1"
  },
  "peerDependencies": {
    "@stacks/connect": ">=7.0.0",
    "@stacks/network": ">=6.0.0",
    "@stacks/transactions": ">=6.0.0"
  },
  "publishConfig": {
    "access": "public"
  }
}
</file>

<file path="README.md">
# Blaze SDK

A lightweight SDK for managing off-chain transfers with on-chain settlement for Stacks dapps. Enables batching multiple transfers into single transactions for improved efficiency and UX.

## Installation

```bash
npm install blaze-sdk
```

## Overview

The Blaze SDK provides a simple interface for managing token transfers on Stacks subnets, with support for both client-side and server-side operations. It handles:

- Off-chain transfer signing and validation
- On-chain deposit and withdrawal operations
- Balance tracking across subnets
- Batched transfer processing for improved efficiency

## Usage

### Client-Side Usage

```typescript
import { Blaze } from 'blaze-sdk';

// Initialize with subnet contract and signer address
const blaze = new Blaze('SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.subnet', 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG');

// Check balance
const balance = await blaze.getBalance();
console.log('Balance:', balance);

// Make a transfer
await blaze.transfer({
    to: 'ST2CY5V39NHDPWSXMW9QDT3HC3GD6Q6XX4CFRK9AG',
    amount: 1000000 // amount in microtokens
});

// Deposit tokens to subnet
await blaze.deposit(1000000);

// Withdraw tokens from subnet
await blaze.withdraw(1000000);
```

### Server-Side Usage

For server-side operations, set your private key as an environment variable:

```bash
export PRIVATE_KEY=your_private_key_here
```

Then use the same API as client-side, but in a Node.js environment:

```typescript
import { Blaze } from 'blaze-sdk';

const blaze = new Blaze('SP2PABAF9FTAJYNFZH93XENAJ8FVY99RRM50D2JG9.subnet', serverAddress);
// The SDK will automatically detect server environment and use the private key
```

## API Reference

### `Blaze` Class

#### Constructor
```typescript
new Blaze(subnet: string, signer: string)
```
- `subnet`: The contract address of the subnet
- `signer`: The Stacks address of the signer

#### Methods

##### `getBalance()`
Returns the current balance for the signer in the subnet.

Returns: `Promise<Balance>`
```typescript
interface Balance {
    confirmed: number;   // On-chain balance in microtokens
    unconfirmed: number; // Pending balance changes in microtokens
}
```

##### `transfer(options: TransferOptions)`
Initiates a transfer within the subnet.

Parameters:
```typescript
interface TransferOptions {
    to: string;    // Recipient address
    amount: number; // Amount in microtokens
}
```

##### `deposit(amount: number)`
Deposits tokens from the main chain to the subnet.

Parameters:
- `amount`: Amount in microtokens to deposit

##### `withdraw(amount: number)`
Withdraws tokens from the subnet to the main chain.

Parameters:
- `amount`: Amount in microtokens to withdraw

## Technical Details

### Transaction Handling

The SDK handles two types of transactions:
1. Single transfers: Process individual transfers
2. Batch transfers: Combine multiple transfers into a single transaction

### Environment Detection

The SDK automatically detects whether it's running in a browser or server environment:
- Browser: Uses @stacks/connect for user interactions
- Server: Uses private key for automated signing

### Network Configuration

Currently supports:
- Network: Stacks Mainnet
- Default fee: 1800 microstacks

## Dependencies

Core dependencies:
- @stacks/connect: ^7.0.2
- @stacks/network: ^7.0.2
- @stacks/transactions: ^7.0.2
- axios: ^1.7.9

## Best Practices

1. Always check balances before transfers
2. Handle transaction errors appropriately
3. Keep private keys secure in server environments
4. Use appropriate error handling for user interactions
5. Monitor transaction status after broadcast

## Limitations

- Mainnet only (no testnet support currently)
- Single subnet per instance
- Requires environment-specific setup (browser vs server)
- Transaction fees are fixed at 1800 microstacks

## License

MIT
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "lib": [
      "ES2020",
      "DOM"
    ],
    "moduleResolution": "node",
    "esModuleInterop": true,
    "strict": true,
    "strictNullChecks": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "skipDefaultLibCheck": true,
    "declaration": true,
    "outDir": "./dist"
  },
  "include": [
    "src"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "tests"
  ]
}
</file>

<file path="tsup.config.ts">
import { defineConfig } from 'tsup';
export default defineConfig({
    entry: ['src/index.ts'],
    format: ['cjs', 'esm'],
    dts: true,
    splitting: false,
    sourcemap: true,
    clean: true,
    treeshake: true,
});
</file>

<file path="vitest.config.ts">
import { defineConfig } from "vitest/config";
import 'dotenv/config';
export default defineConfig({
  test: {
    globals: true,
    environment: "node",
    testTimeout: 30000, // 30 seconds since we're using real network
    setupFiles: ['./tests/setup.ts'],
    coverage: {
      provider: "v8",
      reporter: ["text", "json", "html"],
      exclude: [
        "node_modules/",
        "dist/",
        "**/*.test.ts",
        "**/*.spec.ts",
        "**/types/**",
      ],
    },
    env: process.env.PRIVATE_KEY ? {
      PRIVATE_KEY: process.env.PRIVATE_KEY,
    } : {},
  },
});
</file>

</files>
